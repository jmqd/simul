* DONE Poisson creation helper functions for Agents
* TODO Add =ObjectiveFunction= type definition (once type impl Trait is supported in Stable)
#+BEGIN_SRC rust
/// An ObjectiveFunction is used in simulated annealing and it is the function
/// that we try to maximize when running many simulations.
///
/// For more information on simulated annealing and objective functions, you can refer to the following resources:
/// - Simulated annealing: https://en.wikipedia.org/wiki/Simulated_annealing
/// - Objective function: https://en.wikipedia.org/wiki/Objective_function
///
/// Here is an example usage, in this case findinng the fastest simulation without wasting
/// cycles on too fast of a consuming agent:
/// ```
/// let objective_fn: ObjectiveFunction = |s: &Simulation| {
///    -(s.time as i64)
///        + s.agents
///            .iter()
///            .find(|a| a.name == "consumer")
///            .as_ref()
///            .unwrap()
///            .common_traits
///            .as_ref()
///            .unwrap()
///            .period
///            .unwrap() as i64
/// }
/// ```
pub type ObjectiveFunction = impl Fn(&Simulation) -> i64;
#+END_SRC
* TODO Remove the "stringly-typed" feel of agents currently.
Change the API so that agent names are statically determined?
* DONE Add SimulationParams struct and pass it into the constructor.
This is to make it more readable etc.
* TODO Consider adding params struct for construction of Agents too.
* DONE Rename =Ticket= to =Message= or =Packet= for better readability.
Also considering "Event"
* TODO Add experiment in experiment.rs to support running same experiment over
   and over for getting precise confidence interval
* DONE Remove env_logger dependency
Note: Moved to dev-dependencies
* TODO If possible, move =log= dependency to feature
* TODO Implement a sort of "next-event" optimization to skip ticks that don't produce events
* TODO Address all uses of =unwrap()=
* TODO Gracefully degrade Simulations into Failed state in cases of errors
* TODO Re-evaluate targeting system architecture for messages -- should agents be passed as a graph?
Should agents be in charge of which tickets they receive?
* TODO Parallelize experiment running.
* TODO Consider adding Experiment structure for better interface
* TODO Add Generic data field for Messages
* TODO Consider allowing Messages w/ no target -- fanout / global broadcast
* TODO Add doctests throughout
* TODO Cleanup and/or separate binary from library
* TODO Fully-integrate plotters feature into library
* TODO Consider replacing halt_check with a fn that returns SimulationState enum
